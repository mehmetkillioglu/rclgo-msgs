/*
This file is part of rclgo

Copyright Â© 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

/*
THIS FILE IS AUTOGENERATED BY 'rclgo-gen generate'
*/

package actionlib_msgs_msg
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo/types"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	primitives "github.com/tiiuae/rclgo/pkg/rclgo/primitives"
	
)
/*
#cgo LDFLAGS: -L/opt/ros/galactic/lib -Wl,-rpath=/opt/ros/galactic/lib -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation
#cgo LDFLAGS: -lactionlib_msgs__rosidl_typesupport_c -lactionlib_msgs__rosidl_generator_c

#cgo CFLAGS: -I/opt/ros/galactic/include

#include <rosidl_runtime_c/message_type_support_struct.h>

#include <actionlib_msgs/msg/goal_status.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("actionlib_msgs/GoalStatus", GoalStatusTypeSupport)
}
const (
	GoalStatus_PENDING uint8 = 0// The goal has yet to be processed by the action server.
	GoalStatus_ACTIVE uint8 = 1// The goal is currently being processed by the action server.
	GoalStatus_PREEMPTED uint8 = 2// The goal received a cancel request after it started executing
	GoalStatus_SUCCEEDED uint8 = 3// The goal was achieved successfully by the action server. and has since completed its execution (Terminal State).
	GoalStatus_ABORTED uint8 = 4// The goal was aborted during execution by the action server due. and has since completed its execution (Terminal State).(Terminal State).
	GoalStatus_REJECTED uint8 = 5// The goal was rejected by the action server without being processed,. and has since completed its execution (Terminal State).(Terminal State).to some failure (Terminal State).
	GoalStatus_PREEMPTING uint8 = 6// The goal received a cancel request after it started executing. and has since completed its execution (Terminal State).(Terminal State).to some failure (Terminal State).because the goal was unattainable or invalid (Terminal State).
	GoalStatus_RECALLING uint8 = 7// The goal received a cancel request before it started executing, but. and has since completed its execution (Terminal State).(Terminal State).to some failure (Terminal State).because the goal was unattainable or invalid (Terminal State).and has not yet completed execution.
	GoalStatus_RECALLED uint8 = 8// The goal received a cancel request before it started executing. and has since completed its execution (Terminal State).(Terminal State).to some failure (Terminal State).because the goal was unattainable or invalid (Terminal State).and has not yet completed execution.the action server has not yet confirmed that the goal is canceled.
	GoalStatus_LOST uint8 = 9// An action client can determine that a goal is LOST. This should not. and has since completed its execution (Terminal State).(Terminal State).to some failure (Terminal State).because the goal was unattainable or invalid (Terminal State).and has not yet completed execution.the action server has not yet confirmed that the goal is canceled.and was successfully cancelled (Terminal State).
)

// Do not create instances of this type directly. Always use NewGoalStatus
// function instead.
type GoalStatus struct {
	GoalId GoalID `yaml:"goal_id"`
	Status uint8 `yaml:"status"`
	Text string `yaml:"text"`// Allow for the user to associate a string with GoalStatus for debugging.
}

// NewGoalStatus creates a new GoalStatus with default values.
func NewGoalStatus() *GoalStatus {
	self := GoalStatus{}
	self.SetDefaults()
	return &self
}

func (t *GoalStatus) Clone() *GoalStatus {
	c := &GoalStatus{}
	c.GoalId = *t.GoalId.Clone()
	c.Status = t.Status
	c.Text = t.Text
	return c
}

func (t *GoalStatus) CloneMsg() types.Message {
	return t.Clone()
}

func (t *GoalStatus) SetDefaults() {
	t.GoalId.SetDefaults()
	t.Status = 0
	t.Text = ""
}

// CloneGoalStatusSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneGoalStatusSlice(dst, src []GoalStatus) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var GoalStatusTypeSupport types.MessageTypeSupport = _GoalStatusTypeSupport{}

type _GoalStatusTypeSupport struct{}

func (t _GoalStatusTypeSupport) New() types.Message {
	return NewGoalStatus()
}

func (t _GoalStatusTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.actionlib_msgs__msg__GoalStatus
	return (unsafe.Pointer)(C.actionlib_msgs__msg__GoalStatus__create())
}

func (t _GoalStatusTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.actionlib_msgs__msg__GoalStatus__destroy((*C.actionlib_msgs__msg__GoalStatus)(pointer_to_free))
}

func (t _GoalStatusTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*GoalStatus)
	mem := (*C.actionlib_msgs__msg__GoalStatus)(dst)
	GoalIDTypeSupport.AsCStruct(unsafe.Pointer(&mem.goal_id), &m.GoalId)
	mem.status = C.uint8_t(m.Status)
	primitives.StringAsCStruct(unsafe.Pointer(&mem.text), m.Text)
}

func (t _GoalStatusTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*GoalStatus)
	mem := (*C.actionlib_msgs__msg__GoalStatus)(ros2_message_buffer)
	GoalIDTypeSupport.AsGoStruct(&m.GoalId, unsafe.Pointer(&mem.goal_id))
	m.Status = uint8(mem.status)
	primitives.StringAsGoStruct(&m.Text, unsafe.Pointer(&mem.text))
}

func (t _GoalStatusTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__actionlib_msgs__msg__GoalStatus())
}

type CGoalStatus = C.actionlib_msgs__msg__GoalStatus
type CGoalStatus__Sequence = C.actionlib_msgs__msg__GoalStatus__Sequence

func GoalStatus__Sequence_to_Go(goSlice *[]GoalStatus, cSlice CGoalStatus__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]GoalStatus, int64(cSlice.size))
	for i := 0; i < int(cSlice.size); i++ {
		cIdx := (*C.actionlib_msgs__msg__GoalStatus__Sequence)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_actionlib_msgs__msg__GoalStatus * uintptr(i)),
		))
		GoalStatusTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(cIdx))
	}
}
func GoalStatus__Sequence_to_C(cSlice *CGoalStatus__Sequence, goSlice []GoalStatus) {
	if len(goSlice) == 0 {
		return
	}
	cSlice.data = (*C.actionlib_msgs__msg__GoalStatus)(C.malloc((C.size_t)(C.sizeof_struct_actionlib_msgs__msg__GoalStatus * uintptr(len(goSlice)))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity

	for i, v := range goSlice {
		cIdx := (*C.actionlib_msgs__msg__GoalStatus)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_actionlib_msgs__msg__GoalStatus * uintptr(i)),
		))
		GoalStatusTypeSupport.AsCStruct(unsafe.Pointer(cIdx), &v)
	}
}
func GoalStatus__Array_to_Go(goSlice []GoalStatus, cSlice []CGoalStatus) {
	for i := 0; i < len(cSlice); i++ {
		GoalStatusTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func GoalStatus__Array_to_C(cSlice []CGoalStatus, goSlice []GoalStatus) {
	for i := 0; i < len(goSlice); i++ {
		GoalStatusTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
