/*
This file is part of rclgo

Copyright Â© 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

/*
THIS FILE IS AUTOGENERATED BY 'rclgo-gen generate'
*/

package px4_msgs_msg
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo/types"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	
)
/*
#cgo LDFLAGS: -L/opt/ros/galactic/lib -Wl,-rpath=/opt/ros/galactic/lib -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation
#cgo LDFLAGS: -lpx4_msgs__rosidl_typesupport_c -lpx4_msgs__rosidl_generator_c

#cgo CFLAGS: -I/opt/ros/galactic/include

#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/cellular_status.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/CellularStatus", CellularStatusTypeSupport)
}
const (
	CellularStatus_CELLULAR_STATUS_FLAG_UNKNOWN uint8 = 0// State unknown or not reportable
	CellularStatus_CELLULAR_STATUS_FLAG_FAILED uint8 = 1// velocity setpoint
	CellularStatus_CELLULAR_STATUS_FLAG_INITIALIZING uint8 = 2// Modem is being initialized
	CellularStatus_CELLULAR_STATUS_FLAG_LOCKED uint8 = 3// Modem is locked
	CellularStatus_CELLULAR_STATUS_FLAG_DISABLED uint8 = 4// Modem is not enabled and is powered down
	CellularStatus_CELLULAR_STATUS_FLAG_DISABLING uint8 = 5// Modem is currently transitioning to the CELLULAR_STATUS_FLAG_DISABLED state
	CellularStatus_CELLULAR_STATUS_FLAG_ENABLING uint8 = 6// Modem is currently transitioning to the CELLULAR_STATUS_FLAG_ENABLED state
	CellularStatus_CELLULAR_STATUS_FLAG_ENABLED uint8 = 7// Modem is enabled and powered on but not registered with a network provider and not available for data connections
	CellularStatus_CELLULAR_STATUS_FLAG_SEARCHING uint8 = 8// Modem is searching for a network provider to register
	CellularStatus_CELLULAR_STATUS_FLAG_REGISTERED uint8 = 9// Modem is registered with a network provider, and data connections and messaging may be available for use
	CellularStatus_CELLULAR_STATUS_FLAG_DISCONNECTING uint8 = 10// Modem is disconnecting and deactivating the last active packet data bearer. This state will not be entered if more than one packet data bearer is active and one of the active bearers is deactivated
	CellularStatus_CELLULAR_STATUS_FLAG_CONNECTING uint8 = 11// Modem is activating and connecting the first packet data bearer. Subsequent bearer activations when another bearer is already active do not cause this state to be entered
	CellularStatus_CELLULAR_STATUS_FLAG_CONNECTED uint8 = 12// One or more packet data bearers is active and connected
	CellularStatus_CELLULAR_NETWORK_FAILED_REASON_NONE uint8 = 0// No error
	CellularStatus_CELLULAR_NETWORK_FAILED_REASON_UNKNOWN uint8 = 1// Error state is unknown
	CellularStatus_CELLULAR_NETWORK_FAILED_REASON_SIM_MISSING uint8 = 2// SIM is required for the modem but missing
	CellularStatus_CELLULAR_NETWORK_FAILED_REASON_SIM_ERROR uint8 = 3// SIM is available, but not usuable for connection
)

// Do not create instances of this type directly. Always use NewCellularStatus
// function instead.
type CellularStatus struct {
	Timestamp uint64 `yaml:"timestamp"`// time since system start (microseconds)
	Status uint16 `yaml:"status"`// Status bitmap 1: Roaming is active
	FailureReason uint8 `yaml:"failure_reason"`// Failure reason when status in in CELLUAR_STATUS_FAILED
	Type uint8 `yaml:"type"`// Cellular network radio type 0: none 1: gsm 2: cdma 3: wcdma 4: lte
	Quality uint8 `yaml:"quality"`// Cellular network RSSI/RSRP in dBm, absolute value
	Mcc uint16 `yaml:"mcc"`// Mobile country code. If unknown, set to: UINT16_MAX
	Mnc uint16 `yaml:"mnc"`// Mobile network code. If unknown, set to: UINT16_MAX
	Lac uint16 `yaml:"lac"`// Location area code. If unknown, set to: 0
}

// NewCellularStatus creates a new CellularStatus with default values.
func NewCellularStatus() *CellularStatus {
	self := CellularStatus{}
	self.SetDefaults()
	return &self
}

func (t *CellularStatus) Clone() *CellularStatus {
	c := &CellularStatus{}
	c.Timestamp = t.Timestamp
	c.Status = t.Status
	c.FailureReason = t.FailureReason
	c.Type = t.Type
	c.Quality = t.Quality
	c.Mcc = t.Mcc
	c.Mnc = t.Mnc
	c.Lac = t.Lac
	return c
}

func (t *CellularStatus) CloneMsg() types.Message {
	return t.Clone()
}

func (t *CellularStatus) SetDefaults() {
	t.Timestamp = 0
	t.Status = 0
	t.FailureReason = 0
	t.Type = 0
	t.Quality = 0
	t.Mcc = 0
	t.Mnc = 0
	t.Lac = 0
}

// CloneCellularStatusSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneCellularStatusSlice(dst, src []CellularStatus) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var CellularStatusTypeSupport types.MessageTypeSupport = _CellularStatusTypeSupport{}

type _CellularStatusTypeSupport struct{}

func (t _CellularStatusTypeSupport) New() types.Message {
	return NewCellularStatus()
}

func (t _CellularStatusTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__CellularStatus
	return (unsafe.Pointer)(C.px4_msgs__msg__CellularStatus__create())
}

func (t _CellularStatusTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__CellularStatus__destroy((*C.px4_msgs__msg__CellularStatus)(pointer_to_free))
}

func (t _CellularStatusTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*CellularStatus)
	mem := (*C.px4_msgs__msg__CellularStatus)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.status = C.uint16_t(m.Status)
	mem.failure_reason = C.uint8_t(m.FailureReason)
	mem._type = C.uint8_t(m.Type)
	mem.quality = C.uint8_t(m.Quality)
	mem.mcc = C.uint16_t(m.Mcc)
	mem.mnc = C.uint16_t(m.Mnc)
	mem.lac = C.uint16_t(m.Lac)
}

func (t _CellularStatusTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*CellularStatus)
	mem := (*C.px4_msgs__msg__CellularStatus)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.Status = uint16(mem.status)
	m.FailureReason = uint8(mem.failure_reason)
	m.Type = uint8(mem._type)
	m.Quality = uint8(mem.quality)
	m.Mcc = uint16(mem.mcc)
	m.Mnc = uint16(mem.mnc)
	m.Lac = uint16(mem.lac)
}

func (t _CellularStatusTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__CellularStatus())
}

type CCellularStatus = C.px4_msgs__msg__CellularStatus
type CCellularStatus__Sequence = C.px4_msgs__msg__CellularStatus__Sequence

func CellularStatus__Sequence_to_Go(goSlice *[]CellularStatus, cSlice CCellularStatus__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]CellularStatus, int64(cSlice.size))
	for i := 0; i < int(cSlice.size); i++ {
		cIdx := (*C.px4_msgs__msg__CellularStatus__Sequence)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_px4_msgs__msg__CellularStatus * uintptr(i)),
		))
		CellularStatusTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(cIdx))
	}
}
func CellularStatus__Sequence_to_C(cSlice *CCellularStatus__Sequence, goSlice []CellularStatus) {
	if len(goSlice) == 0 {
		return
	}
	cSlice.data = (*C.px4_msgs__msg__CellularStatus)(C.malloc((C.size_t)(C.sizeof_struct_px4_msgs__msg__CellularStatus * uintptr(len(goSlice)))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity

	for i, v := range goSlice {
		cIdx := (*C.px4_msgs__msg__CellularStatus)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_px4_msgs__msg__CellularStatus * uintptr(i)),
		))
		CellularStatusTypeSupport.AsCStruct(unsafe.Pointer(cIdx), &v)
	}
}
func CellularStatus__Array_to_Go(goSlice []CellularStatus, cSlice []CCellularStatus) {
	for i := 0; i < len(cSlice); i++ {
		CellularStatusTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func CellularStatus__Array_to_C(cSlice []CCellularStatus, goSlice []CellularStatus) {
	for i := 0; i < len(goSlice); i++ {
		CellularStatusTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
