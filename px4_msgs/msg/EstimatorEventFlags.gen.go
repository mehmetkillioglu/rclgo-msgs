/*
This file is part of rclgo

Copyright Â© 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

/*
THIS FILE IS AUTOGENERATED BY 'rclgo-gen generate'
*/

package px4_msgs_msg
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo/types"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	
)
/*
#cgo LDFLAGS: -L/opt/ros/galactic/lib -Wl,-rpath=/opt/ros/galactic/lib -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation
#cgo LDFLAGS: -lpx4_msgs__rosidl_typesupport_c -lpx4_msgs__rosidl_generator_c

#cgo CFLAGS: -I/opt/ros/galactic/include

#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/estimator_event_flags.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/EstimatorEventFlags", EstimatorEventFlagsTypeSupport)
}

// Do not create instances of this type directly. Always use NewEstimatorEventFlags
// function instead.
type EstimatorEventFlags struct {
	Timestamp uint64 `yaml:"timestamp"`// time since system start (microseconds)
	TimestampSample uint64 `yaml:"timestamp_sample"`// the timestamp of the raw data (microseconds)
	InformationEventChanges uint32 `yaml:"information_event_changes"`// number of information event changes. information events
	GpsChecksPassed bool `yaml:"gps_checks_passed"`// 0 - true when gps quality checks are passing passed. information events
	ResetVelToGps bool `yaml:"reset_vel_to_gps"`// 1 - true when the velocity states are reset to the gps measurement. information events
	ResetVelToFlow bool `yaml:"reset_vel_to_flow"`// 2 - true when the velocity states are reset using the optical flow measurement. information events
	ResetVelToVision bool `yaml:"reset_vel_to_vision"`// 3 - true when the velocity states are reset to the vision system measurement. information events
	ResetVelToZero bool `yaml:"reset_vel_to_zero"`// 4 - true when the velocity states are reset to zero. information events
	ResetPosToLastKnown bool `yaml:"reset_pos_to_last_known"`// 5 - true when the position states are reset to the last known position. information events
	ResetPosToGps bool `yaml:"reset_pos_to_gps"`// 6 - true when the position states are reset to the gps measurement. information events
	ResetPosToVision bool `yaml:"reset_pos_to_vision"`// 7 - true when the position states are reset to the vision system measurement. information events
	StartingGpsFusion bool `yaml:"starting_gps_fusion"`// 8 - true when the filter starts using gps measurements to correct the state estimates. information events
	StartingVisionPosFusion bool `yaml:"starting_vision_pos_fusion"`// 9 - true when the filter starts using vision system position measurements to correct the state estimates. information events
	StartingVisionVelFusion bool `yaml:"starting_vision_vel_fusion"`// 10 - true when the filter starts using vision system velocity measurements to correct the state estimates. information events
	StartingVisionYawFusion bool `yaml:"starting_vision_yaw_fusion"`// 11 - true when the filter starts using vision system yaw  measurements to correct the state estimates. information events
	YawAlignedToImuGps bool `yaml:"yaw_aligned_to_imu_gps"`// 12 - true when the filter resets the yaw to an estimate derived from IMU and GPS data. information events
	WarningEventChanges uint32 `yaml:"warning_event_changes"`// number of warning event changes. warning events
	GpsQualityPoor bool `yaml:"gps_quality_poor"`// 0 - true when the gps is failing quality checks. warning events
	GpsFusionTimout bool `yaml:"gps_fusion_timout"`// 1 - true when the gps data has not been used to correct the state estimates for a significant time period. warning events
	GpsDataStopped bool `yaml:"gps_data_stopped"`// 2 - true when the gps data has stopped for a significant time period. warning events
	GpsDataStoppedUsingAlternate bool `yaml:"gps_data_stopped_using_alternate"`// 3 - true when the gps data has stopped for a significant time period but the filter is able to use other sources of data to maintain navigation. warning events
	HeightSensorTimeout bool `yaml:"height_sensor_timeout"`// 4 - true when the height sensor has not been used to correct the state estimates for a significant time period. warning events
	StoppingNavigation bool `yaml:"stopping_navigation"`// 5 - true when the filter has insufficient data to estimate velocity and position and is falling back to an attitude, height and height rate mode of operation. warning events
	InvalidAccelBiasCovReset bool `yaml:"invalid_accel_bias_cov_reset"`// 6 - true when the filter has detected bad acceerometer bias state esitmstes and has reset the corresponding covariance matrix elements. warning events
	BadYawUsingGpsCourse bool `yaml:"bad_yaw_using_gps_course"`// 7 - true when the fiter has detected an invalid yaw esitmate and has reset the yaw angle to the GPS ground course. warning events
	StoppingMagUse bool `yaml:"stopping_mag_use"`// 8 - true when the filter has detected bad magnetometer data and is stopping further use of the magnetomer data. warning events
	VisionDataStopped bool `yaml:"vision_data_stopped"`// 9 - true when the vision system data has stopped for a significant time period. warning events
	EmergencyYawResetMagStopped bool `yaml:"emergency_yaw_reset_mag_stopped"`// 10 - true when the filter has detected bad magnetometer data, has reset the yaw to anothter source of data and has stopped further use of the magnetomer data. warning events
}

// NewEstimatorEventFlags creates a new EstimatorEventFlags with default values.
func NewEstimatorEventFlags() *EstimatorEventFlags {
	self := EstimatorEventFlags{}
	self.SetDefaults()
	return &self
}

func (t *EstimatorEventFlags) Clone() *EstimatorEventFlags {
	c := &EstimatorEventFlags{}
	c.Timestamp = t.Timestamp
	c.TimestampSample = t.TimestampSample
	c.InformationEventChanges = t.InformationEventChanges
	c.GpsChecksPassed = t.GpsChecksPassed
	c.ResetVelToGps = t.ResetVelToGps
	c.ResetVelToFlow = t.ResetVelToFlow
	c.ResetVelToVision = t.ResetVelToVision
	c.ResetVelToZero = t.ResetVelToZero
	c.ResetPosToLastKnown = t.ResetPosToLastKnown
	c.ResetPosToGps = t.ResetPosToGps
	c.ResetPosToVision = t.ResetPosToVision
	c.StartingGpsFusion = t.StartingGpsFusion
	c.StartingVisionPosFusion = t.StartingVisionPosFusion
	c.StartingVisionVelFusion = t.StartingVisionVelFusion
	c.StartingVisionYawFusion = t.StartingVisionYawFusion
	c.YawAlignedToImuGps = t.YawAlignedToImuGps
	c.WarningEventChanges = t.WarningEventChanges
	c.GpsQualityPoor = t.GpsQualityPoor
	c.GpsFusionTimout = t.GpsFusionTimout
	c.GpsDataStopped = t.GpsDataStopped
	c.GpsDataStoppedUsingAlternate = t.GpsDataStoppedUsingAlternate
	c.HeightSensorTimeout = t.HeightSensorTimeout
	c.StoppingNavigation = t.StoppingNavigation
	c.InvalidAccelBiasCovReset = t.InvalidAccelBiasCovReset
	c.BadYawUsingGpsCourse = t.BadYawUsingGpsCourse
	c.StoppingMagUse = t.StoppingMagUse
	c.VisionDataStopped = t.VisionDataStopped
	c.EmergencyYawResetMagStopped = t.EmergencyYawResetMagStopped
	return c
}

func (t *EstimatorEventFlags) CloneMsg() types.Message {
	return t.Clone()
}

func (t *EstimatorEventFlags) SetDefaults() {
	t.Timestamp = 0
	t.TimestampSample = 0
	t.InformationEventChanges = 0
	t.GpsChecksPassed = false
	t.ResetVelToGps = false
	t.ResetVelToFlow = false
	t.ResetVelToVision = false
	t.ResetVelToZero = false
	t.ResetPosToLastKnown = false
	t.ResetPosToGps = false
	t.ResetPosToVision = false
	t.StartingGpsFusion = false
	t.StartingVisionPosFusion = false
	t.StartingVisionVelFusion = false
	t.StartingVisionYawFusion = false
	t.YawAlignedToImuGps = false
	t.WarningEventChanges = 0
	t.GpsQualityPoor = false
	t.GpsFusionTimout = false
	t.GpsDataStopped = false
	t.GpsDataStoppedUsingAlternate = false
	t.HeightSensorTimeout = false
	t.StoppingNavigation = false
	t.InvalidAccelBiasCovReset = false
	t.BadYawUsingGpsCourse = false
	t.StoppingMagUse = false
	t.VisionDataStopped = false
	t.EmergencyYawResetMagStopped = false
}

// CloneEstimatorEventFlagsSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneEstimatorEventFlagsSlice(dst, src []EstimatorEventFlags) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var EstimatorEventFlagsTypeSupport types.MessageTypeSupport = _EstimatorEventFlagsTypeSupport{}

type _EstimatorEventFlagsTypeSupport struct{}

func (t _EstimatorEventFlagsTypeSupport) New() types.Message {
	return NewEstimatorEventFlags()
}

func (t _EstimatorEventFlagsTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__EstimatorEventFlags
	return (unsafe.Pointer)(C.px4_msgs__msg__EstimatorEventFlags__create())
}

func (t _EstimatorEventFlagsTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__EstimatorEventFlags__destroy((*C.px4_msgs__msg__EstimatorEventFlags)(pointer_to_free))
}

func (t _EstimatorEventFlagsTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*EstimatorEventFlags)
	mem := (*C.px4_msgs__msg__EstimatorEventFlags)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.timestamp_sample = C.uint64_t(m.TimestampSample)
	mem.information_event_changes = C.uint32_t(m.InformationEventChanges)
	mem.gps_checks_passed = C.bool(m.GpsChecksPassed)
	mem.reset_vel_to_gps = C.bool(m.ResetVelToGps)
	mem.reset_vel_to_flow = C.bool(m.ResetVelToFlow)
	mem.reset_vel_to_vision = C.bool(m.ResetVelToVision)
	mem.reset_vel_to_zero = C.bool(m.ResetVelToZero)
	mem.reset_pos_to_last_known = C.bool(m.ResetPosToLastKnown)
	mem.reset_pos_to_gps = C.bool(m.ResetPosToGps)
	mem.reset_pos_to_vision = C.bool(m.ResetPosToVision)
	mem.starting_gps_fusion = C.bool(m.StartingGpsFusion)
	mem.starting_vision_pos_fusion = C.bool(m.StartingVisionPosFusion)
	mem.starting_vision_vel_fusion = C.bool(m.StartingVisionVelFusion)
	mem.starting_vision_yaw_fusion = C.bool(m.StartingVisionYawFusion)
	mem.yaw_aligned_to_imu_gps = C.bool(m.YawAlignedToImuGps)
	mem.warning_event_changes = C.uint32_t(m.WarningEventChanges)
	mem.gps_quality_poor = C.bool(m.GpsQualityPoor)
	mem.gps_fusion_timout = C.bool(m.GpsFusionTimout)
	mem.gps_data_stopped = C.bool(m.GpsDataStopped)
	mem.gps_data_stopped_using_alternate = C.bool(m.GpsDataStoppedUsingAlternate)
	mem.height_sensor_timeout = C.bool(m.HeightSensorTimeout)
	mem.stopping_navigation = C.bool(m.StoppingNavigation)
	mem.invalid_accel_bias_cov_reset = C.bool(m.InvalidAccelBiasCovReset)
	mem.bad_yaw_using_gps_course = C.bool(m.BadYawUsingGpsCourse)
	mem.stopping_mag_use = C.bool(m.StoppingMagUse)
	mem.vision_data_stopped = C.bool(m.VisionDataStopped)
	mem.emergency_yaw_reset_mag_stopped = C.bool(m.EmergencyYawResetMagStopped)
}

func (t _EstimatorEventFlagsTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*EstimatorEventFlags)
	mem := (*C.px4_msgs__msg__EstimatorEventFlags)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.TimestampSample = uint64(mem.timestamp_sample)
	m.InformationEventChanges = uint32(mem.information_event_changes)
	m.GpsChecksPassed = bool(mem.gps_checks_passed)
	m.ResetVelToGps = bool(mem.reset_vel_to_gps)
	m.ResetVelToFlow = bool(mem.reset_vel_to_flow)
	m.ResetVelToVision = bool(mem.reset_vel_to_vision)
	m.ResetVelToZero = bool(mem.reset_vel_to_zero)
	m.ResetPosToLastKnown = bool(mem.reset_pos_to_last_known)
	m.ResetPosToGps = bool(mem.reset_pos_to_gps)
	m.ResetPosToVision = bool(mem.reset_pos_to_vision)
	m.StartingGpsFusion = bool(mem.starting_gps_fusion)
	m.StartingVisionPosFusion = bool(mem.starting_vision_pos_fusion)
	m.StartingVisionVelFusion = bool(mem.starting_vision_vel_fusion)
	m.StartingVisionYawFusion = bool(mem.starting_vision_yaw_fusion)
	m.YawAlignedToImuGps = bool(mem.yaw_aligned_to_imu_gps)
	m.WarningEventChanges = uint32(mem.warning_event_changes)
	m.GpsQualityPoor = bool(mem.gps_quality_poor)
	m.GpsFusionTimout = bool(mem.gps_fusion_timout)
	m.GpsDataStopped = bool(mem.gps_data_stopped)
	m.GpsDataStoppedUsingAlternate = bool(mem.gps_data_stopped_using_alternate)
	m.HeightSensorTimeout = bool(mem.height_sensor_timeout)
	m.StoppingNavigation = bool(mem.stopping_navigation)
	m.InvalidAccelBiasCovReset = bool(mem.invalid_accel_bias_cov_reset)
	m.BadYawUsingGpsCourse = bool(mem.bad_yaw_using_gps_course)
	m.StoppingMagUse = bool(mem.stopping_mag_use)
	m.VisionDataStopped = bool(mem.vision_data_stopped)
	m.EmergencyYawResetMagStopped = bool(mem.emergency_yaw_reset_mag_stopped)
}

func (t _EstimatorEventFlagsTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__EstimatorEventFlags())
}

type CEstimatorEventFlags = C.px4_msgs__msg__EstimatorEventFlags
type CEstimatorEventFlags__Sequence = C.px4_msgs__msg__EstimatorEventFlags__Sequence

func EstimatorEventFlags__Sequence_to_Go(goSlice *[]EstimatorEventFlags, cSlice CEstimatorEventFlags__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]EstimatorEventFlags, int64(cSlice.size))
	for i := 0; i < int(cSlice.size); i++ {
		cIdx := (*C.px4_msgs__msg__EstimatorEventFlags__Sequence)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_px4_msgs__msg__EstimatorEventFlags * uintptr(i)),
		))
		EstimatorEventFlagsTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(cIdx))
	}
}
func EstimatorEventFlags__Sequence_to_C(cSlice *CEstimatorEventFlags__Sequence, goSlice []EstimatorEventFlags) {
	if len(goSlice) == 0 {
		return
	}
	cSlice.data = (*C.px4_msgs__msg__EstimatorEventFlags)(C.malloc((C.size_t)(C.sizeof_struct_px4_msgs__msg__EstimatorEventFlags * uintptr(len(goSlice)))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity

	for i, v := range goSlice {
		cIdx := (*C.px4_msgs__msg__EstimatorEventFlags)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_px4_msgs__msg__EstimatorEventFlags * uintptr(i)),
		))
		EstimatorEventFlagsTypeSupport.AsCStruct(unsafe.Pointer(cIdx), &v)
	}
}
func EstimatorEventFlags__Array_to_Go(goSlice []EstimatorEventFlags, cSlice []CEstimatorEventFlags) {
	for i := 0; i < len(cSlice); i++ {
		EstimatorEventFlagsTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func EstimatorEventFlags__Array_to_C(cSlice []CEstimatorEventFlags, goSlice []EstimatorEventFlags) {
	for i := 0; i < len(goSlice); i++ {
		EstimatorEventFlagsTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
