/*
This file is part of rclgo

Copyright Â© 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

/*
THIS FILE IS AUTOGENERATED BY 'rclgo-gen generate'
*/

package px4_msgs_msg
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo/types"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	primitives "github.com/tiiuae/rclgo/pkg/rclgo/primitives"
	
)
/*
#cgo LDFLAGS: -L/opt/ros/galactic/lib -Wl,-rpath=/opt/ros/galactic/lib -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation
#cgo LDFLAGS: -lpx4_msgs__rosidl_typesupport_c -lpx4_msgs__rosidl_generator_c

#cgo CFLAGS: -I/opt/ros/galactic/include

#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/px4_io_status.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/Px4IoStatus", Px4IoStatusTypeSupport)
}

// Do not create instances of this type directly. Always use NewPx4IoStatus
// function instead.
type Px4IoStatus struct {
	Timestamp uint64 `yaml:"timestamp"`// time since system start (microseconds)
	FreeMemoryBytes uint16 `yaml:"free_memory_bytes"`
	VoltageV float32 `yaml:"voltage_v"`// Servo rail voltage in volts
	RssiV float32 `yaml:"rssi_v"`// RSSI pin voltage in volts
	StatusOutputsArmed bool `yaml:"status_outputs_armed"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusOverride bool `yaml:"status_override"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusRcOk bool `yaml:"status_rc_ok"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusRcPpm bool `yaml:"status_rc_ppm"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusRcDsm bool `yaml:"status_rc_dsm"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusRcSbus bool `yaml:"status_rc_sbus"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusFmuOk bool `yaml:"status_fmu_ok"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusRawPwm bool `yaml:"status_raw_pwm"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusMixerOk bool `yaml:"status_mixer_ok"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusArmSync bool `yaml:"status_arm_sync"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusInitOk bool `yaml:"status_init_ok"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusFailsafe bool `yaml:"status_failsafe"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusSafetyOff bool `yaml:"status_safety_off"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusFmuInitialized bool `yaml:"status_fmu_initialized"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusRcSt24 bool `yaml:"status_rc_st24"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusRcSumd bool `yaml:"status_rc_sumd"`// PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	AlarmVbattLow bool `yaml:"alarm_vbatt_low"`// PX4IO alarms (PX4IO_P_STATUS_ALARMS)
	AlarmTemperature bool `yaml:"alarm_temperature"`// PX4IO alarms (PX4IO_P_STATUS_ALARMS)
	AlarmServoCurrent bool `yaml:"alarm_servo_current"`// PX4IO alarms (PX4IO_P_STATUS_ALARMS)
	AlarmAccCurrent bool `yaml:"alarm_acc_current"`// PX4IO alarms (PX4IO_P_STATUS_ALARMS)
	AlarmFmuLost bool `yaml:"alarm_fmu_lost"`// PX4IO alarms (PX4IO_P_STATUS_ALARMS)
	AlarmRcLost bool `yaml:"alarm_rc_lost"`// PX4IO alarms (PX4IO_P_STATUS_ALARMS)
	AlarmPwmError bool `yaml:"alarm_pwm_error"`// PX4IO alarms (PX4IO_P_STATUS_ALARMS)
	AlarmVservoFault bool `yaml:"alarm_vservo_fault"`// PX4IO alarms (PX4IO_P_STATUS_ALARMS)
	ArmingIoArmOk bool `yaml:"arming_io_arm_ok"`// PX4IO arming (PX4IO_P_SETUP_ARMING)
	ArmingFmuArmed bool `yaml:"arming_fmu_armed"`// PX4IO arming (PX4IO_P_SETUP_ARMING)
	ArmingFmuPrearmed bool `yaml:"arming_fmu_prearmed"`// PX4IO arming (PX4IO_P_SETUP_ARMING)
	ArmingManualOverrideOk bool `yaml:"arming_manual_override_ok"`// PX4IO arming (PX4IO_P_SETUP_ARMING)
	ArmingFailsafeCustom bool `yaml:"arming_failsafe_custom"`// PX4IO arming (PX4IO_P_SETUP_ARMING)
	ArmingInairRestartOk bool `yaml:"arming_inair_restart_ok"`// PX4IO arming (PX4IO_P_SETUP_ARMING)
	ArmingAlwaysPwmEnable bool `yaml:"arming_always_pwm_enable"`// PX4IO arming (PX4IO_P_SETUP_ARMING)
	ArmingRcHandlingDisabled bool `yaml:"arming_rc_handling_disabled"`// PX4IO arming (PX4IO_P_SETUP_ARMING)
	ArmingLockdown bool `yaml:"arming_lockdown"`// PX4IO arming (PX4IO_P_SETUP_ARMING)
	ArmingForceFailsafe bool `yaml:"arming_force_failsafe"`// PX4IO arming (PX4IO_P_SETUP_ARMING)
	ArmingTerminationFailsafe bool `yaml:"arming_termination_failsafe"`// PX4IO arming (PX4IO_P_SETUP_ARMING)
	ArmingOverrideImmediate bool `yaml:"arming_override_immediate"`// PX4IO arming (PX4IO_P_SETUP_ARMING)
	Actuators [8]int16 `yaml:"actuators"`
	Servos [8]uint16 `yaml:"servos"`
	RawInputs [18]uint16 `yaml:"raw_inputs"`
}

// NewPx4IoStatus creates a new Px4IoStatus with default values.
func NewPx4IoStatus() *Px4IoStatus {
	self := Px4IoStatus{}
	self.SetDefaults()
	return &self
}

func (t *Px4IoStatus) Clone() *Px4IoStatus {
	c := &Px4IoStatus{}
	c.Timestamp = t.Timestamp
	c.FreeMemoryBytes = t.FreeMemoryBytes
	c.VoltageV = t.VoltageV
	c.RssiV = t.RssiV
	c.StatusOutputsArmed = t.StatusOutputsArmed
	c.StatusOverride = t.StatusOverride
	c.StatusRcOk = t.StatusRcOk
	c.StatusRcPpm = t.StatusRcPpm
	c.StatusRcDsm = t.StatusRcDsm
	c.StatusRcSbus = t.StatusRcSbus
	c.StatusFmuOk = t.StatusFmuOk
	c.StatusRawPwm = t.StatusRawPwm
	c.StatusMixerOk = t.StatusMixerOk
	c.StatusArmSync = t.StatusArmSync
	c.StatusInitOk = t.StatusInitOk
	c.StatusFailsafe = t.StatusFailsafe
	c.StatusSafetyOff = t.StatusSafetyOff
	c.StatusFmuInitialized = t.StatusFmuInitialized
	c.StatusRcSt24 = t.StatusRcSt24
	c.StatusRcSumd = t.StatusRcSumd
	c.AlarmVbattLow = t.AlarmVbattLow
	c.AlarmTemperature = t.AlarmTemperature
	c.AlarmServoCurrent = t.AlarmServoCurrent
	c.AlarmAccCurrent = t.AlarmAccCurrent
	c.AlarmFmuLost = t.AlarmFmuLost
	c.AlarmRcLost = t.AlarmRcLost
	c.AlarmPwmError = t.AlarmPwmError
	c.AlarmVservoFault = t.AlarmVservoFault
	c.ArmingIoArmOk = t.ArmingIoArmOk
	c.ArmingFmuArmed = t.ArmingFmuArmed
	c.ArmingFmuPrearmed = t.ArmingFmuPrearmed
	c.ArmingManualOverrideOk = t.ArmingManualOverrideOk
	c.ArmingFailsafeCustom = t.ArmingFailsafeCustom
	c.ArmingInairRestartOk = t.ArmingInairRestartOk
	c.ArmingAlwaysPwmEnable = t.ArmingAlwaysPwmEnable
	c.ArmingRcHandlingDisabled = t.ArmingRcHandlingDisabled
	c.ArmingLockdown = t.ArmingLockdown
	c.ArmingForceFailsafe = t.ArmingForceFailsafe
	c.ArmingTerminationFailsafe = t.ArmingTerminationFailsafe
	c.ArmingOverrideImmediate = t.ArmingOverrideImmediate
	c.Actuators = t.Actuators
	c.Servos = t.Servos
	c.RawInputs = t.RawInputs
	return c
}

func (t *Px4IoStatus) CloneMsg() types.Message {
	return t.Clone()
}

func (t *Px4IoStatus) SetDefaults() {
	t.Timestamp = 0
	t.FreeMemoryBytes = 0
	t.VoltageV = 0
	t.RssiV = 0
	t.StatusOutputsArmed = false
	t.StatusOverride = false
	t.StatusRcOk = false
	t.StatusRcPpm = false
	t.StatusRcDsm = false
	t.StatusRcSbus = false
	t.StatusFmuOk = false
	t.StatusRawPwm = false
	t.StatusMixerOk = false
	t.StatusArmSync = false
	t.StatusInitOk = false
	t.StatusFailsafe = false
	t.StatusSafetyOff = false
	t.StatusFmuInitialized = false
	t.StatusRcSt24 = false
	t.StatusRcSumd = false
	t.AlarmVbattLow = false
	t.AlarmTemperature = false
	t.AlarmServoCurrent = false
	t.AlarmAccCurrent = false
	t.AlarmFmuLost = false
	t.AlarmRcLost = false
	t.AlarmPwmError = false
	t.AlarmVservoFault = false
	t.ArmingIoArmOk = false
	t.ArmingFmuArmed = false
	t.ArmingFmuPrearmed = false
	t.ArmingManualOverrideOk = false
	t.ArmingFailsafeCustom = false
	t.ArmingInairRestartOk = false
	t.ArmingAlwaysPwmEnable = false
	t.ArmingRcHandlingDisabled = false
	t.ArmingLockdown = false
	t.ArmingForceFailsafe = false
	t.ArmingTerminationFailsafe = false
	t.ArmingOverrideImmediate = false
	t.Actuators = [8]int16{}
	t.Servos = [8]uint16{}
	t.RawInputs = [18]uint16{}
}

// ClonePx4IoStatusSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func ClonePx4IoStatusSlice(dst, src []Px4IoStatus) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var Px4IoStatusTypeSupport types.MessageTypeSupport = _Px4IoStatusTypeSupport{}

type _Px4IoStatusTypeSupport struct{}

func (t _Px4IoStatusTypeSupport) New() types.Message {
	return NewPx4IoStatus()
}

func (t _Px4IoStatusTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__Px4IoStatus
	return (unsafe.Pointer)(C.px4_msgs__msg__Px4IoStatus__create())
}

func (t _Px4IoStatusTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__Px4IoStatus__destroy((*C.px4_msgs__msg__Px4IoStatus)(pointer_to_free))
}

func (t _Px4IoStatusTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*Px4IoStatus)
	mem := (*C.px4_msgs__msg__Px4IoStatus)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.free_memory_bytes = C.uint16_t(m.FreeMemoryBytes)
	mem.voltage_v = C.float(m.VoltageV)
	mem.rssi_v = C.float(m.RssiV)
	mem.status_outputs_armed = C.bool(m.StatusOutputsArmed)
	mem.status_override = C.bool(m.StatusOverride)
	mem.status_rc_ok = C.bool(m.StatusRcOk)
	mem.status_rc_ppm = C.bool(m.StatusRcPpm)
	mem.status_rc_dsm = C.bool(m.StatusRcDsm)
	mem.status_rc_sbus = C.bool(m.StatusRcSbus)
	mem.status_fmu_ok = C.bool(m.StatusFmuOk)
	mem.status_raw_pwm = C.bool(m.StatusRawPwm)
	mem.status_mixer_ok = C.bool(m.StatusMixerOk)
	mem.status_arm_sync = C.bool(m.StatusArmSync)
	mem.status_init_ok = C.bool(m.StatusInitOk)
	mem.status_failsafe = C.bool(m.StatusFailsafe)
	mem.status_safety_off = C.bool(m.StatusSafetyOff)
	mem.status_fmu_initialized = C.bool(m.StatusFmuInitialized)
	mem.status_rc_st24 = C.bool(m.StatusRcSt24)
	mem.status_rc_sumd = C.bool(m.StatusRcSumd)
	mem.alarm_vbatt_low = C.bool(m.AlarmVbattLow)
	mem.alarm_temperature = C.bool(m.AlarmTemperature)
	mem.alarm_servo_current = C.bool(m.AlarmServoCurrent)
	mem.alarm_acc_current = C.bool(m.AlarmAccCurrent)
	mem.alarm_fmu_lost = C.bool(m.AlarmFmuLost)
	mem.alarm_rc_lost = C.bool(m.AlarmRcLost)
	mem.alarm_pwm_error = C.bool(m.AlarmPwmError)
	mem.alarm_vservo_fault = C.bool(m.AlarmVservoFault)
	mem.arming_io_arm_ok = C.bool(m.ArmingIoArmOk)
	mem.arming_fmu_armed = C.bool(m.ArmingFmuArmed)
	mem.arming_fmu_prearmed = C.bool(m.ArmingFmuPrearmed)
	mem.arming_manual_override_ok = C.bool(m.ArmingManualOverrideOk)
	mem.arming_failsafe_custom = C.bool(m.ArmingFailsafeCustom)
	mem.arming_inair_restart_ok = C.bool(m.ArmingInairRestartOk)
	mem.arming_always_pwm_enable = C.bool(m.ArmingAlwaysPwmEnable)
	mem.arming_rc_handling_disabled = C.bool(m.ArmingRcHandlingDisabled)
	mem.arming_lockdown = C.bool(m.ArmingLockdown)
	mem.arming_force_failsafe = C.bool(m.ArmingForceFailsafe)
	mem.arming_termination_failsafe = C.bool(m.ArmingTerminationFailsafe)
	mem.arming_override_immediate = C.bool(m.ArmingOverrideImmediate)
	cSlice_actuators := mem.actuators[:]
	primitives.Int16__Array_to_C(*(*[]primitives.CInt16)(unsafe.Pointer(&cSlice_actuators)), m.Actuators[:])
	cSlice_servos := mem.servos[:]
	primitives.Uint16__Array_to_C(*(*[]primitives.CUint16)(unsafe.Pointer(&cSlice_servos)), m.Servos[:])
	cSlice_raw_inputs := mem.raw_inputs[:]
	primitives.Uint16__Array_to_C(*(*[]primitives.CUint16)(unsafe.Pointer(&cSlice_raw_inputs)), m.RawInputs[:])
}

func (t _Px4IoStatusTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*Px4IoStatus)
	mem := (*C.px4_msgs__msg__Px4IoStatus)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.FreeMemoryBytes = uint16(mem.free_memory_bytes)
	m.VoltageV = float32(mem.voltage_v)
	m.RssiV = float32(mem.rssi_v)
	m.StatusOutputsArmed = bool(mem.status_outputs_armed)
	m.StatusOverride = bool(mem.status_override)
	m.StatusRcOk = bool(mem.status_rc_ok)
	m.StatusRcPpm = bool(mem.status_rc_ppm)
	m.StatusRcDsm = bool(mem.status_rc_dsm)
	m.StatusRcSbus = bool(mem.status_rc_sbus)
	m.StatusFmuOk = bool(mem.status_fmu_ok)
	m.StatusRawPwm = bool(mem.status_raw_pwm)
	m.StatusMixerOk = bool(mem.status_mixer_ok)
	m.StatusArmSync = bool(mem.status_arm_sync)
	m.StatusInitOk = bool(mem.status_init_ok)
	m.StatusFailsafe = bool(mem.status_failsafe)
	m.StatusSafetyOff = bool(mem.status_safety_off)
	m.StatusFmuInitialized = bool(mem.status_fmu_initialized)
	m.StatusRcSt24 = bool(mem.status_rc_st24)
	m.StatusRcSumd = bool(mem.status_rc_sumd)
	m.AlarmVbattLow = bool(mem.alarm_vbatt_low)
	m.AlarmTemperature = bool(mem.alarm_temperature)
	m.AlarmServoCurrent = bool(mem.alarm_servo_current)
	m.AlarmAccCurrent = bool(mem.alarm_acc_current)
	m.AlarmFmuLost = bool(mem.alarm_fmu_lost)
	m.AlarmRcLost = bool(mem.alarm_rc_lost)
	m.AlarmPwmError = bool(mem.alarm_pwm_error)
	m.AlarmVservoFault = bool(mem.alarm_vservo_fault)
	m.ArmingIoArmOk = bool(mem.arming_io_arm_ok)
	m.ArmingFmuArmed = bool(mem.arming_fmu_armed)
	m.ArmingFmuPrearmed = bool(mem.arming_fmu_prearmed)
	m.ArmingManualOverrideOk = bool(mem.arming_manual_override_ok)
	m.ArmingFailsafeCustom = bool(mem.arming_failsafe_custom)
	m.ArmingInairRestartOk = bool(mem.arming_inair_restart_ok)
	m.ArmingAlwaysPwmEnable = bool(mem.arming_always_pwm_enable)
	m.ArmingRcHandlingDisabled = bool(mem.arming_rc_handling_disabled)
	m.ArmingLockdown = bool(mem.arming_lockdown)
	m.ArmingForceFailsafe = bool(mem.arming_force_failsafe)
	m.ArmingTerminationFailsafe = bool(mem.arming_termination_failsafe)
	m.ArmingOverrideImmediate = bool(mem.arming_override_immediate)
	cSlice_actuators := mem.actuators[:]
	primitives.Int16__Array_to_Go(m.Actuators[:], *(*[]primitives.CInt16)(unsafe.Pointer(&cSlice_actuators)))
	cSlice_servos := mem.servos[:]
	primitives.Uint16__Array_to_Go(m.Servos[:], *(*[]primitives.CUint16)(unsafe.Pointer(&cSlice_servos)))
	cSlice_raw_inputs := mem.raw_inputs[:]
	primitives.Uint16__Array_to_Go(m.RawInputs[:], *(*[]primitives.CUint16)(unsafe.Pointer(&cSlice_raw_inputs)))
}

func (t _Px4IoStatusTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__Px4IoStatus())
}

type CPx4IoStatus = C.px4_msgs__msg__Px4IoStatus
type CPx4IoStatus__Sequence = C.px4_msgs__msg__Px4IoStatus__Sequence

func Px4IoStatus__Sequence_to_Go(goSlice *[]Px4IoStatus, cSlice CPx4IoStatus__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]Px4IoStatus, int64(cSlice.size))
	for i := 0; i < int(cSlice.size); i++ {
		cIdx := (*C.px4_msgs__msg__Px4IoStatus__Sequence)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_px4_msgs__msg__Px4IoStatus * uintptr(i)),
		))
		Px4IoStatusTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(cIdx))
	}
}
func Px4IoStatus__Sequence_to_C(cSlice *CPx4IoStatus__Sequence, goSlice []Px4IoStatus) {
	if len(goSlice) == 0 {
		return
	}
	cSlice.data = (*C.px4_msgs__msg__Px4IoStatus)(C.malloc((C.size_t)(C.sizeof_struct_px4_msgs__msg__Px4IoStatus * uintptr(len(goSlice)))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity

	for i, v := range goSlice {
		cIdx := (*C.px4_msgs__msg__Px4IoStatus)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_px4_msgs__msg__Px4IoStatus * uintptr(i)),
		))
		Px4IoStatusTypeSupport.AsCStruct(unsafe.Pointer(cIdx), &v)
	}
}
func Px4IoStatus__Array_to_Go(goSlice []Px4IoStatus, cSlice []CPx4IoStatus) {
	for i := 0; i < len(cSlice); i++ {
		Px4IoStatusTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func Px4IoStatus__Array_to_C(cSlice []CPx4IoStatus, goSlice []Px4IoStatus) {
	for i := 0; i < len(goSlice); i++ {
		Px4IoStatusTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
